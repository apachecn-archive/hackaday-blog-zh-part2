# AVR 硬件定时器被骗成一次性的

> 原文:[https://hack aday . com/2015/03/24/AVR-hardware-timer-tricked-to-one-shot/](https://hackaday.com/2015/03/24/avr-hardware-timer-tricked-into-one-shot/)

[Josh]写了两个帖子，使用 AVR 的人可能会觉得很方便。第一篇文章记录了一个 C 库，它实现了一个无抖动的单次定时器。[第二篇文章解释了它是如何工作的](http://wp.josh.com/2015/03/12/avr-timer-based-one-shot-explained/)。我们认为这是一个很好的想法，我们会破坏它，但继续阅读他的链接，检查他的代码。

一个[单触发](https://en.wikipedia.org/wiki/Programmable_interval_timer)是运行一次且仅运行一次的脉冲发生器。你触发它，它就会产生想要的脉冲，她就写了这么多。为什么这很方便？您将与之接口的许多外部 IC 都有必须遵守的信号脉冲最小持续时间。您可以对 AVR 进行编程，将一个引脚切换至高电平，然后等待，直到再次将该引脚切换至低电平，但这将浪费宝贵的 CPU 时间，不会非常精确，而且如果中断例程同时触发，还容易出现时序差异。

您可能认为可以使用硬件定时器来实现这一点，但这并不简单。通常，定时器是自由运行的；记录时间的计数器翻转过来，重新开始。但我们只想要一个脉冲。

[Josh]非常聪明的想法是在“快速 PWM”模式下滥用计时器/计数器的顶部和匹配值。本质上，你通过设置顶部低于匹配来欺骗计数器使其永远不匹配。这意味着计数器永远在零和顶部之间循环旋转，什么也不做。

要使它脱离循环并启用单次触发，您需要手动将计数器设置为高于 TOP 的值，然后释放它。当它计数时，它最终会匹配，打开你的 pin，然后继续计数。当它翻转到顶部时(8 位 AVR 为 255 + 1 = 0)，您的 pin 将再次正确关闭，然后计数器重新进入循环。只有再次手动将计数器设置为高于 TOP，单次触发才会触发。

这就是你要做的，一次触发只依赖于硬件定时器/计数器模块，因此不受抖动影响，完全不消耗 CPU 时间。我们向你脱帽致敬，[乔希]。聪明的黑客。