# 初学者看片上调试

> 原文：<https://hackaday.com/2012/09/27/beginners-look-at-on-chip-debugging/>

[https://www.youtube.com/embed/NSVOuHToJ6c?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent](https://www.youtube.com/embed/NSVOuHToJ6c?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent)

随着你的嵌入式应用变得越来越复杂，当运行不正常时，片上调试器将为你节省大量时间。片上调试(OCD)顾名思义是一种在目标芯片上运行程序的方式，它允许您暂停执行来检查值并在需要时更改它们。Arduino 没有使用 OCD 的内置方法，但主板使用的 AVR 芯片有。需要注意的是，你需要一个合适的 AVR 程序员来访问 Debug Wire 协议，或者一些较大芯片的 JTAG 接口。在这种情况下，我将使用 STM32 Discovery Board 来概述 OCD。但是这对于任何具有硬件调试能力的芯片都是一样的。许多 IDE 都内置了调试支持，这样您就可以在工作时使用漂亮的 GUI。但是这些通常只是我将要使用的命令行工具的前端。休息后加入我，我们将开始。

## 为什么要使用片上调试？

最近我在编写一个 ARM 芯片上的贪吃蛇游戏。我让它正常工作，可以玩几分钟，但之后事情会变得很糟糕。这很可能是代码中的一个错误，但也可能是启动或链接程序脚本导致的内存问题、打字错误或其他一些事情。使用 OCD，我能够在不到五分钟的时间内找到并修复错误。和软件调试一样，我只需要在程序的某个部分设置一个断点，这是我对问题的最佳猜测。这立即缩小了范围，我所要做的就是扫描大约 20 行代码来指出我的错误。

## 软件

为了进行这种类型的调试，你需要三样东西:一个控制芯片调试模式的程序，一个与芯片接口的方法，以及一个编译了调试信息的程序。

接口部分很简单，我们将使用 GDB ( [GNU 调试器](http://www.gnu.org/software/gdb/))。几乎在所有情况下，这个程序都包含在与 GCC 编译器相同的工具链中。由于 GDB 在几乎所有的情况下都被使用，所以值得你花时间去学习如何使用它。如果你是一个软件人员，很可能你已经有了。

在我的例子中，我使用 [OpenOCD](http://openocd.sourceforge.net/) 来控制我的 ARM 处理器的调试特性。它提供了一个 GDB 连接的港口。该平台支持大量芯片，因此稍加搜索就可以找到与不同芯片对话所需的命令/配置文件。在我的例子中，STM32-Discovery F0 板具有内置支持。

要使用调试信息进行编译，只需在使用 GCC 时添加'-g '编译器标志。对我来说，这只会影响。所以我总是在 makefile 中包含这个标志。

## 让一切运转起来

先决条件:我不会介绍安装工具链或 OpenOCD。我做了一些工作，为在 Linux 上开发 STM32 F0 项目制作了一个模板[。自述文件中有详细说明获取工具链和编译支持 ST-LINK 的 OpenOCD。](http://hackaday.com/2012/06/17/template-for-building-stm32f0-discovery-project-in-gcc/)

**关键先决条件:** 无论何时调试，你都需要确保你已经使用'-g '标志编译了你的程序。这就产生了 GDB 将你的 C 代码与芯片上运行的机器码联系起来所需的信息。

**启动 OpenOCD**

连接调试硬件(如果是发现板，只需将其插入 USB 端口)后，我启动 OpenOCD，指定要使用的板特定配置。OpenOCD 附带了很多板卡文件。你很少会第一个调试任何类型的硬件，所以应该有现成的配置文件。以下是我对发现板使用的命令:

```
openocd -f /usr/share/openocd/scripts/board/stm32f0discovery.cfg
```

OpenOCD 现在应该正在运行，是时候启动 GDB 了。

**启动 GDB 并连接到 OpenOCD**

启动 GDB 时，告诉它使用哪个调试文件是个好主意。这将是。编译带有“-g”标志的代码时生成的“elf”文件。不要使用简单的命令“gdb ”,这一点非常重要。这确实会启动 GNU 调试器，但不是 ARM 调试所必需的。为此，我们需要使用用于编译 ARM 代码的交叉编译工具链的命令:

```
arm-none-eabi-gdb main.elf
```

一旦 GDB 启动，我们需要告诉它连接到我们的目标芯片。这是通过几个关键字和 OpenOCD 一直监听的一个端口完成的:

```
target remote :3333
```

现在我们已经连接好了，可以使用 GDB 命令开始调试了。

## 使用 GDB

理论上，你可以在调试的时候修改你的程序，并把它刷新到芯片上。我拥有的软件工具不提供这种硬件的功能(这是一个较新的芯片组，自从我编译 OpenOCD 以来已经有很长时间了，所以这可能已经改变了)。以下是一些适用于大多数芯片的通用命令:

*   文件——告诉 GDB 使用哪个文件进行调试(我在启动 GDB 时将它作为参数传递)
*   加载–将二进制文件闪存到芯片上(不适用于我的 STM 32 f 0 发现板)
*   monitor–向服务器发送特殊命令(OpenOCD)

我用监视器命令来控制芯片。为了复位芯片(在设置断点等之后)，命令“监视器复位暂停”告诉 OpenOCD 复位 ARM 处理器，但不要开始程序执行。

调试时将使用的基本命令包括:

*   继续–开始程序执行，除非出现断点/观察点/等，否则不要停止。已达到
*   break–添加断点。这可以指定为一个函数或一行代码的名称。当执行到达这一点时，处理器将暂停，您可以检查您的数据
*   打印–打印变量或内存地址的值。使用它来查看您的代码有什么问题
*   显示–每次到达断点时，在指定变量上执行“打印”命令

这里列出的命令实在太多了。大多数 GDB 命令是平台无关的，所以搜索技巧和提示应该很简单。我发现最好的工具是这个 [GDB 参考卡](http://www.cs.berkeley.edu/~mavam/teaching/cs161-sp11/gdb-refcard.pdf) (PDF)。我将让您自己来看一看，但是需要注意的一点是“下一步”和“下一步”命令之间的区别。Next 将让处理器运行，直到到达下一行代码，如果出现函数调用，则执行函数调用。Step 会做同样的事情，但是它不会跟随任何函数调用。

最好的办法是观看演示视频，然后亲自尝试调试。只需在谷歌上搜索一下，就能获得帮助，而且交易的诀窍也很容易学会。祝你好运！