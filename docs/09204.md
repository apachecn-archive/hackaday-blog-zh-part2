# 嵌入 Elliot:多路复用 SPI 使用较少的引脚

> 原文:[https://hack aday . com/2015/06/05/embed-with-Elliot-multiplexing-SPI-uses-less-pins/](https://hackaday.com/2015/06/05/embed-with-elliot-multiplexing-spi-uses-few-pins/)

[Ralph Doncaster]，又名 Nerdralph，似乎非常想知道他可以在微控制器上使用多么少的资源来完成工作。[在他的博客](http://nerdralph.blogspot.ca/2015/05/nrf24l01-control-with-2-mcu-pins-using.html)上的这篇文章中，【Ralph】编写了一些自定义的位碰撞 SPI 代码，将驱动 nRF24L01+无线电模块所需的 SPI 线路数量从四条减少到两条。如果你使用的是只有 6 个空闲管脚的微处理器，比如 ATtiny85，这真的很有帮助。

如果你要说，“你为什么不买一个更大的微控制器？”，你没抓住重点。这种做法让我们觉得是为了优化而优化，是一种肮脏的黑客行为，这两者都有利于它。这里也有一些技巧可以作为你的心理工具箱。我们认为这很有趣，值得深入研究。

在我们开始之前，用三句话告诉你需要了解的关于 SPI 的事情。SPI 通常使用四条线进行简单的主机/从机设置。主机设置一条芯片选择线(CS)让从机知道它正在被通话，并开始切换时钟线(SCK)。另外两条线路用于从主机向从机传输数据(简称为主机输出从机输入或 MOSI)以及从从机向主机传输数据(MISO)。那么[拉尔夫]如何将这四个合二为一呢？

## 第一招

[![TDDSPI](../Images/01b545b275dbfc09ff92eb130a1d68aa.png)](https://hackaday.com/wp-content/uploads/2015/06/tddspi.png) 为了合并时钟和芯片选择线，[拉尔夫]的电路依赖于对[的修改，这是他以前使用过的一个技巧](http://hackaday.com/2014/02/16/nrf24l01-using-3-attiny85-pins/)。请注意，无线电模块上的 CSN 线通过一个电阻和一个接地电容(通过一个低通滤波器)连接到微控制器上的 SCK。设置正确的值(这将取决于时钟频率)后，CSN 上的值将是 SCK 线上的平均电压，就像当您[使用低通滤波器平滑“模拟”PWM 输出](http://hackaday.com/2011/06/16/beginner-concepts-using-a-low-pass-filter-to-smooth-pwm-output/)时一样。

如果时钟运行时，时钟使用足够窄的脉冲宽度来平均逻辑低，则 CSN 线将被拉到某个中间电压，该电压足够低，以至于在时钟滴答时被解释为逻辑低，nRF24L01+将开始侦听。[Ralph]的自定义 SPI 代码使用 25%的占空比来实现这一功能。

当微控制器完成发送时钟信号时，它会在相对较长的时间内保持时钟线为高电平，将 CSN 线拉高，并让 nRF24L01+知道它不再被通话。

## 第二招

[![wavedrom](../Images/2ac6c5f5509b7df48c7319ce2c7bdb53.png)](https://hackaday.com/wp-content/uploads/2015/06/wavedrom2.png) 现在我们来看看 hack 把味噌和 MOSI 复用成“MOMI”的情况。

正常情况下，在本例中，在低电平时钟转换之后，主机和从机同时在各自的输出线上设置下一个数据位。然后双方在看到时钟线再次翻转为高电平后读取各自的输入线。

在[Ralph]的双工方案中，主机在设置周期内偷偷对单个“MOMI”线进行读取和写入。(注意，我们在上图中使用了对称时钟，而不是[Ralph]芯片选择攻击所需的 25%占空比。)

当时钟变为低电平时，nRF24L01+开始在其 MISO 线上设置所需的输出电压，然后由微控制器读取。在此建立期间，微处理器切换到输出模式，并在线路上建立所需的电压，然后再次将时钟切换到高电平，向 nRF24L01+发送信号以从线路上读取。然后，主机将引脚切换回输入，允许 nRF24L01+控制线路，但不读取。最后，微处理器丢弃时钟，为下一位重复该周期。

有两件事[拉尔夫]需要得到正确的，使这种双重工作，第一是时间。在低电平时钟转换时，nRF24L01+设置其输出电压。微控制器能够可靠地读取该电压需要一点时间，该时间取决于线路电容、电阻 R2 的值和 nRF24L01+输出驱动器的强度。

[![TDDSPI](../Images/01b545b275dbfc09ff92eb130a1d68aa.png)](https://hackaday.com/wp-content/uploads/2015/06/tddspi.png) 然后，在微控制器读取 nRF24L01+的电压后，它会在线路上施加自己的输出电压，然后再次将时钟切换为高电平，向 nRF24L01+发送信号以读取该值。这里，需要选择足够大的 R2，使微控制器能够覆盖 nRF24L01+自身的 MISO 信号。

因此，选择电阻 R2 是关键。必须选择足够小的电压，以便 nRF24L01+可以在微控制器读取之前在共享线路上设置所需的电压。但电阻也必须足够大，以便微控制器可以轻松覆盖 nRF24L01+通过 MISO 输入的自身输出。[Ralph]使用示波器来选择正确的 R2 值，它工作了。

## 结论

但这可能也是为什么这种类型的安排在野外不多见。工程师们喜欢简单的协议，这些协议能够在不同的电路布局中可靠地工作，并且带有额外的噪声。在这里，[Ralph]对 CSN 使用了一个低但不是数字的信号电平，然后根据线路电容和 nRF24L01+的输出驱动器强度手工选择一个电阻，这不是北欧制造芯片的规格。换句话说，如果你在家尝试的话，准备好调整 R2 的值或者玩 SPI 计时。

总之，这是一个很好的技巧——试图通过手工调整一个受约束的系统，使其达到任何合理的工程师都做不到的程度，从而最大限度地利用它。我们喜欢这样。但是这样做，是不是生活在边缘？还是整个系统比我们的内部工程师认为的更加稳健？你的想法是什么，如果尝试，你的体验是什么？

* * *

*Embed with Elliot* 是一个专栏，微控制器专家[埃利奥特·威廉姆斯]在其中探索和解释嵌入式系统有趣、聪明、独特、奇怪、有时甚至错误的用法。通过[发送下一期的提示](mailto:tips@hackaday.com?Subject=[Embed_with_Elliot])，帮助保持本专栏的新鲜感。