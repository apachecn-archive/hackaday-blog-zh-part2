# 嵌入 Elliot:Volatile 关键字

> 原文:[https://hack aday . com/2015/08/18/embed-with-Elliot-the-volatile-keyword/](https://hackaday.com/2015/08/18/embed-with-elliot-the-volatile-keyword/)

上一次在《嵌入埃利奥特》中，我们[谈到了`static`关键字](http://hackaday.com/2015/08/04/embed-with-elliot-the-static-keyword-you-dont-fully-understand/)，你可以在声明变量或函数时使用它来增加变量的持续时间，而不会像使用`global`变量那样扩大范围。这激起了我们一些读者的好奇心，我们认为我们碰到了另一个(有时被误解的)变量声明选项，即`volatile`关键字。

从表面上看，`volatile`很简单。您使用它来告诉编译器，声明的变量可以在没有通知的情况下改变，这改变了编译器针对该变量进行优化的方式。在大型计算机编程中，你几乎不会在 c 中使用`volatile`。但是在嵌入式世界中，我们会在一个微不足道的和两个非常重要的情况下使用`volatile`,所以值得一看。

### 优化和编译器的思想

警告优化器一个变量可能会在没有通知的情况下改变，所以我们需要知道为什么这很重要。为此，我们将快速浏览一下(一种)编译器优化的逻辑。

因为内存空间被认为是稀缺的，所以编译器会想确保你没有浪费它。一个快速简单的方法是检查所有的变量，以及所有调用它们的函数，看看它们是否被改变了，或者它们只是伪装的常量。简而言之，这意味着当编译器看到如下愚蠢的东西时:

```

int a = 5;
int b = 0;

b = a + 2;
printf(&quot;%d\n&quot;, b);

```

编译器会注意到，除了一个地方你把它设置为等于 5 之外，你从来没有在代码中的任何地方使用过`a`，尽管你把`b`初始化为零，但你所做的只是给`a`加 2，并把它存储在`b`中。编译器会看穿你所有的愚蠢行为，并会编译出与下面代码等价的代码:

```

printf(&quot;%d\n&quot;, 7);

```

这就是优化！它去掉了两个永远不会改变的变量，并释放了两个字节的内存。但是，这里给我们的教训是，我们必须小心，当我们给编译器一个错误的印象，认为没有什么变化，而实际上却是这样。而这就是`volatile`的本质用途。

在我们离开优化之前，`volatile`的“反义词”并不像人们在语言学上预期的那样是`static`。`static`修改变量的范围。事实上，如果你想定义一个文件范围的、持久的变量，它可以在没有警告的情况下改变，这是很常见的，你应该使用`static volatile`。(编辑:毫无意义，也是错误的，除了关于`const`在评论中受到抨击后被删除。)

### 延迟环路

也许初学者第一次想使用`volatile`是在写延迟程序的时候。最简单的延迟例程只是让 CPU 忙于计数到某个非常大的数字。也就是说，您将尝试这样的事情:

```

int i;
for (i=0; i&lt;65000; ++i){
	; // just wait
}

```

希望它能让电脑变慢，但可能不会。

如果您关闭了优化，或者如果它被设置到一个足够低的水平，它实际上会工作。但是随着任何真正的优化的进行，编译器将会注意到你实际上从来没有使用*变量`i`做任何事情，并且它将优化你的代码如下:*

这不是一个很好的延迟功能。

解决方法是将`i`声明为`volatile`。编译器现在假装不知道`i`什么时候可以改变，或者什么时候会被其他函数使用，它尽职尽责地运行完整的`for`循环，以防万一。

```

volatile int i;
for (i=0; i&lt;65000; ++i){
	; // run anyway, because something _could_ happen to i here
}

```

(注意，这段代码同样可以在您的桌面上演示`volatile`限定符，但是您不会注意到延迟，除非您计数到一个非常大的数字。我们尝试了 65，000，000，它在我们的台式机上暂停了一秒钟。)

这是一个微不足道的例子。接下来的两个是真实的 bug，一直困扰着现实生活中的嵌入式程序员。

### 中断服务程序

ISR 本质上只在正常程序流之外被调用，这自然会使编译器感到困惑。事实上，ISR 将编译器视为从未被调用的函数，因此 AVR-GCC 中的`ISR`定义包含了特殊的“used”属性，这样函数就不会被完全丢弃。所以你可以猜到，当你想在一个函数中修改或使用一个变量，而编译器甚至不知道这个变量会被使用时，事情会变得很糟糕。

好消息是，您只需将变量声明为一个`volatile`全局变量(在`main`和相关 ISR 的范围之外),一切正常。解决方案非常简单，但是如果你不这么做，就不会抛出错误，你的 ISR 也不会工作，因为编译器会用一个常量替换这个变量。

下面是一个简单例子中正确的方法:

```

volatile uint16_t counter=0;

ISR(timer_interrupt_vector){
	++counter;
}

int main(void){
	printf(&quot;%d\n&quot;, counter);
}

```

如果 counter 没有被标记为`volatile`，你可以看到它在`main`的上下文中看起来像一个常量，对吗？现在你不会陷入这种常见的初学者陷阱。

### 存储器映射硬件寄存器

嵌入式编程中`volatile`的第二个重要用途是在[内存映射硬件](https://en.wikipedia.org/wiki/Memory-mapped_I/O)的声明中；微控制器通过在其各种引脚上读取和写入电压来与外界交互，引脚状态通常作为内存中专门映射的位置供您的代码使用。例如，当引脚配置为输入时，您的代码可以从特定的内存位置读取一位，以测试引脚是处于逻辑高电平还是低电平。到目前为止，一切顺利。

但是，当您看到外部电压可能会在没有注意到的情况下发生变化的引脚时，编译器会看到看起来正常的内存位置，除非在您的代码中进行了处理。一般来说，这是由制造商的库处理的，所以你可以假装什么都没发生。但是，既然我们正在研究`volatile`限定符，让我们快速挖掘一下特定于芯片的代码库。

例如，在任何 AVR 项目包含的引脚定义文件中，您可以挖掘定义链，找到用于读取输入的`PIN`寄存器的`volatile`定义:

```

#define PINB    _SFR_IO8 (0x03)
// and
#define _SFR_IO8(io_addr) _MMIO_BYTE((io_addr) + __SFR_OFFSET)
// and finally
#define _MMIO_BYTE(mem_addr) (*(volatile uint8_t *)(mem_addr))

```

Phswew！也就是说，`PINB`变成了一个指向 8 位整数的可变指针，其中指定的内存地址被构建为一个 IO 地址加上一个偏移量。但是这里的要点是，指向这个内存位置的指针被显式声明为`volatile`，编译器知道它是可变的。

ARM 芯片也是如此。在 ARM 标准的 CMSIS 端口定义中，GPIO 内存位置包含在一个更大的`struct`、`GPIO_TypeDef`中，它负责相对内存偏移，但是如果您查看这些类型定义(此处来自 ST 的实现)，您会发现:

```

// in stm32f4xx.h
 __IO uint32_t IDR;      /*!&amp;lt; GPIO port input data register,         Address offset: 0x10      */
// and in core_cm7.h
/* IO definitions (access restrictions to peripheral registers) */
#define     __IO    volatile             /*!&amp;lt; Defines 'read / write' permissions              */

```

Tadaa！如约而至。它确实必须如此，因为否则编译器会查看每个调用数据寄存器的实例，并注意到它们从不改变。

### 包裹

原来如此。简单地说服编译器不要优化一个显然是常量的变量。但是，直到您被由此产生的错误所困扰，您可能甚至不知道编译器能够优化掉什么类型的东西，以及您需要将哪些变量标记为`volatile`。我们已经触及了最常见的陷阱，但是如果我们错过了你使用`volatile`的任何情况，请在下面的评论中让我们知道。