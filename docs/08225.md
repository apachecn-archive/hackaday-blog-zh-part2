# 问黑客日:了解 X86 内存寻址系统

> 原文:[https://hack aday . com/2015/02/03/ask-hack aday-understanding-the-x86-memory-addressing-system/](https://hackaday.com/2015/02/03/ask-hackaday-understanding-the-x86-memory-addressing-system/)

快速浏览一下 Intel 8086 和 8088 处理器的引脚排列，可以发现一条 20 位地址总线。人们对 1 兆(2^20)地址空间的寻址能力有很高的需求，而英特尔满足了这一需求。然而，一个好奇的人可能会想，他们如何只用 16 位寄存器就能实现这样的壮举。英特尔通过合并两个寄存器解决了这个难题，这样他们可以使它与为 8008、8080 和 8085 编写的代码兼容。当试图找出你的代码在 ROM 中的位置时，他们使用的过程可能有点混乱。在本文中，我们将回顾如何计算物理地址以及如何在 ROM 中正确定位代码的基础知识。

![x86 memory map](../Images/6d91df4a43d38ec18dc943df96a23b8a.png)

在 70 年代后期，为了迷惑年轻的初露头角的计算机科学家，Intel 将其 1 兆的地址空间分成四个 64k 的块，每个块由一个 16 位段寄存器表示。段寄存器中的值称为段地址，可以认为是 64k 块之一的基址(0000h)。64k 块中的地址是通过偏移地址找到的。段地址和偏移地址的组合称为逻辑地址，可以转换成难以捉摸的物理地址。在正常取指令时，段地址存储在代码段(CS)寄存器中，偏移地址取自指令指针。因此逻辑地址将是 CS:IP 或例如 FFF0h:C000h。

![registers of x86](../Images/388b83155c52aa569d6b1a42653c37e1.png)

物理地址的形成是通过将段地址乘以 16，然后将其与偏移地址相加来完成的。通过将段地址乘以 16，在右边附加四个 0，可以将它转换为 20 位值。该计算由处理器内的专用加法器完成。但是如果你想知道代码在 ROM 中的位置，你需要知道程序中的地址是如何被转换成物理地址的。这将在下面变得更加清楚。

# 重置向量

既然我们对 x86 地址计算的极其逻辑和直接的内部工作方式感到非常困惑，我们可以继续讨论为什么这些信息是有用的。当 8086 处理器从硬件复位中恢复时，它输出的第一个地址是 FFFF0。这意味着引脚 A0–A3 为低电平，A4–A19 为高电平。

![binary to hex conversion](../Images/61ccd62219d61b332e15f60c87ba8bcc.png)

FFFF0 是物理地址。因此，逻辑地址应该是 FFFF:0000。FFFF 来自代码段(CS)寄存器，0000 来自指令指针(IP)寄存器。这些是复位时寄存器的状态。

现在，你可能已经注意到 FFFF0 非常非常非常接近我们的内存图的底部。的确，只有 16 个字节的距离。所以第一条指令必须是远跳转到内存中更高的地方，加载代码段和指令指针到程序实际开始的地方。多么出色的设计！

# 为什么知道这一点很重要

想从头开始推出自己的 x86 电脑吗？考虑 [8088 SCB 项目](http://sasteven.multics.org/8088page.html)的[这个原理图](http://sasteven.multics.org/8088_SBC_Project/April20-03_8088SBC.pdf) (pdf 警告)。看看处理器，他只使用了 16 条地址线。对于只读存储器，他使用的是 2764 8k x 8 的 EPROM，它有 13 个地址引脚。所以问题是:你在^*#$的什么地方找到 ROM 中的代码？？？等等…是不是…0000h？哦不，那太简单了。

首先，我们必须弄清楚将放在 EPROM 地址引脚上的复位向量地址。8088 将 FFFF0 放在其地址总线上。但是从硬件的角度来看，这个地址实际上是 7FF0。

![binary to hex conversion](../Images/727c618da9389b2d7ed144ef0d71bc89.png)

但是等等，还有呢！2764 EPROM 只有 13 个地址引脚，A0-A12。这意味着当处理器将 FFFF0 放到地址总线上时，EPROM 看到的地址实际上是 1FF0。

![binary to hex conversion](../Images/17644f96a99021e23a914c0287055e39.png)

如果你还没有得到足够的信息，现在你可以知道如何把你的代码(用复位指令)放到 ROM 的正确位置。在这种情况下，远 jmp 必须位于 1FF0。这通常是通过定位器来完成的，定位器是一个程序，它可以剥离。EXE 转换成可以加载到 rom 中的东西。这样的项目并不多，如果你足够幸运能得到一个，请在评论中告诉我们。我还没有找到英特尔的 TLOC.exe，而 Paradigm 已经忽略了我对他们的请求。

下面是一个十六进制转储，显示了[Scott's] 8088 SBC 复位向量的正确位置。EA hex 指令是一个远跳转。远意味着在 64k 段之外。

![hex dump](../Images/b443ad4f1f8d04897a289e3dde8fac7b.png)

现在有人有动力自己做 x86 SBC 吗？[Wichit]做了[这个 80C188 SBC](http://chaokhun.kmitl.ac.th/~kswichit/C188/c188sbc.htm) ，提供了一个很好的起点。我会坚持用 Arduino。

注意:二进制/十六进制转换器的截图来自[这里是](http://www.mathsisfun.com/binary-decimal-hexadecimal-converter.html)。